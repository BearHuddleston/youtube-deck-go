// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
)

const countActiveSubscriptions = `-- name: CountActiveSubscriptions :one
SELECT COUNT(*) FROM subscriptions WHERE active = 1
`

func (q *Queries) CountActiveSubscriptions(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActiveSubscriptions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTotalVideos = `-- name: CountTotalVideos :one
SELECT COUNT(*) FROM videos WHERE subscription_id = ?
`

func (q *Queries) CountTotalVideos(ctx context.Context, subscriptionID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTotalVideos, subscriptionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUnwatchedBySubscription = `-- name: CountUnwatchedBySubscription :one
SELECT COUNT(*) FROM videos WHERE subscription_id = ? AND watched = 0
`

func (q *Queries) CountUnwatchedBySubscription(ctx context.Context, subscriptionID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUnwatchedBySubscription, subscriptionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUnwatchedBySubscriptionFiltered = `-- name: CountUnwatchedBySubscriptionFiltered :one
SELECT COUNT(*) FROM videos
WHERE subscription_id = ?
  AND watched = 0
  AND (? = 0 OR is_short = 0)
`

type CountUnwatchedBySubscriptionFilteredParams struct {
	SubscriptionID int64       `json:"subscription_id"`
	Column2        interface{} `json:"column_2"`
}

func (q *Queries) CountUnwatchedBySubscriptionFiltered(ctx context.Context, arg CountUnwatchedBySubscriptionFilteredParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUnwatchedBySubscriptionFiltered, arg.SubscriptionID, arg.Column2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSubscription = `-- name: CreateSubscription :one
INSERT INTO subscriptions (name, youtube_id, type, thumbnail_url, position, active)
VALUES (?, ?, ?, ?, COALESCE((SELECT MAX(position) FROM subscriptions), 0) + 1, ?)
RETURNING id, name, youtube_id, type, thumbnail_url, last_checked, created_at, position, active, page_token, hide_shorts
`

type CreateSubscriptionParams struct {
	Name         string         `json:"name"`
	YoutubeID    string         `json:"youtube_id"`
	Type         string         `json:"type"`
	ThumbnailUrl sql.NullString `json:"thumbnail_url"`
	Active       sql.NullInt64  `json:"active"`
}

func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRowContext(ctx, createSubscription,
		arg.Name,
		arg.YoutubeID,
		arg.Type,
		arg.ThumbnailUrl,
		arg.Active,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.YoutubeID,
		&i.Type,
		&i.ThumbnailUrl,
		&i.LastChecked,
		&i.CreatedAt,
		&i.Position,
		&i.Active,
		&i.PageToken,
		&i.HideShorts,
	)
	return i, err
}

const createVideo = `-- name: CreateVideo :one
INSERT INTO videos (subscription_id, youtube_id, title, thumbnail_url, duration, published_at, is_short)
VALUES (?, ?, ?, ?, ?, ?, ?)
RETURNING id, subscription_id, youtube_id, title, thumbnail_url, duration, published_at, watched, created_at, is_short
`

type CreateVideoParams struct {
	SubscriptionID int64          `json:"subscription_id"`
	YoutubeID      string         `json:"youtube_id"`
	Title          string         `json:"title"`
	ThumbnailUrl   sql.NullString `json:"thumbnail_url"`
	Duration       sql.NullString `json:"duration"`
	PublishedAt    sql.NullTime   `json:"published_at"`
	IsShort        sql.NullInt64  `json:"is_short"`
}

func (q *Queries) CreateVideo(ctx context.Context, arg CreateVideoParams) (Video, error) {
	row := q.db.QueryRowContext(ctx, createVideo,
		arg.SubscriptionID,
		arg.YoutubeID,
		arg.Title,
		arg.ThumbnailUrl,
		arg.Duration,
		arg.PublishedAt,
		arg.IsShort,
	)
	var i Video
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.YoutubeID,
		&i.Title,
		&i.ThumbnailUrl,
		&i.Duration,
		&i.PublishedAt,
		&i.Watched,
		&i.CreatedAt,
		&i.IsShort,
	)
	return i, err
}

const deleteSubscription = `-- name: DeleteSubscription :exec
DELETE FROM subscriptions WHERE id = ?
`

func (q *Queries) DeleteSubscription(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteSubscription, id)
	return err
}

const filterSubscriptions = `-- name: FilterSubscriptions :many
SELECT s.id, s.name, s.youtube_id, s.type, s.thumbnail_url, s.last_checked, s.created_at, s.position, s.active, s.page_token, s.hide_shorts, COUNT(CASE WHEN v.watched = 0 THEN 1 END) as unwatched_count
FROM subscriptions s
LEFT JOIN videos v ON v.subscription_id = s.id
WHERE s.name LIKE '%' || ? || '%'
GROUP BY s.id
ORDER BY s.position, s.name
LIMIT 50
`

type FilterSubscriptionsRow struct {
	ID             int64          `json:"id"`
	Name           string         `json:"name"`
	YoutubeID      string         `json:"youtube_id"`
	Type           string         `json:"type"`
	ThumbnailUrl   sql.NullString `json:"thumbnail_url"`
	LastChecked    sql.NullTime   `json:"last_checked"`
	CreatedAt      sql.NullTime   `json:"created_at"`
	Position       sql.NullInt64  `json:"position"`
	Active         sql.NullInt64  `json:"active"`
	PageToken      sql.NullString `json:"page_token"`
	HideShorts     sql.NullInt64  `json:"hide_shorts"`
	UnwatchedCount int64          `json:"unwatched_count"`
}

func (q *Queries) FilterSubscriptions(ctx context.Context, dollar_1 sql.NullString) ([]FilterSubscriptionsRow, error) {
	rows, err := q.db.QueryContext(ctx, filterSubscriptions, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FilterSubscriptionsRow{}
	for rows.Next() {
		var i FilterSubscriptionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.YoutubeID,
			&i.Type,
			&i.ThumbnailUrl,
			&i.LastChecked,
			&i.CreatedAt,
			&i.Position,
			&i.Active,
			&i.PageToken,
			&i.HideShorts,
			&i.UnwatchedCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMaxPosition = `-- name: GetMaxPosition :one
SELECT CAST(COALESCE(MAX(position), 0) AS INTEGER) as max_position FROM subscriptions
`

func (q *Queries) GetMaxPosition(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getMaxPosition)
	var max_position int64
	err := row.Scan(&max_position)
	return max_position, err
}

const getSubscription = `-- name: GetSubscription :one
SELECT id, name, youtube_id, type, thumbnail_url, last_checked, created_at, position, active, page_token, hide_shorts FROM subscriptions WHERE id = ?
`

func (q *Queries) GetSubscription(ctx context.Context, id int64) (Subscription, error) {
	row := q.db.QueryRowContext(ctx, getSubscription, id)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.YoutubeID,
		&i.Type,
		&i.ThumbnailUrl,
		&i.LastChecked,
		&i.CreatedAt,
		&i.Position,
		&i.Active,
		&i.PageToken,
		&i.HideShorts,
	)
	return i, err
}

const getVideo = `-- name: GetVideo :one
SELECT id, subscription_id, youtube_id, title, thumbnail_url, duration, published_at, watched, created_at, is_short FROM videos WHERE id = ?
`

func (q *Queries) GetVideo(ctx context.Context, id int64) (Video, error) {
	row := q.db.QueryRowContext(ctx, getVideo, id)
	var i Video
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.YoutubeID,
		&i.Title,
		&i.ThumbnailUrl,
		&i.Duration,
		&i.PublishedAt,
		&i.Watched,
		&i.CreatedAt,
		&i.IsShort,
	)
	return i, err
}

const listActiveSubscriptions = `-- name: ListActiveSubscriptions :many
SELECT s.id, s.name, s.youtube_id, s.type, s.thumbnail_url, s.last_checked, s.created_at, s.position, s.active, s.page_token, s.hide_shorts, COUNT(CASE WHEN v.watched = 0 THEN 1 END) as unwatched_count
FROM subscriptions s
LEFT JOIN videos v ON v.subscription_id = s.id
WHERE s.active = 1
GROUP BY s.id
ORDER BY s.position
`

type ListActiveSubscriptionsRow struct {
	ID             int64          `json:"id"`
	Name           string         `json:"name"`
	YoutubeID      string         `json:"youtube_id"`
	Type           string         `json:"type"`
	ThumbnailUrl   sql.NullString `json:"thumbnail_url"`
	LastChecked    sql.NullTime   `json:"last_checked"`
	CreatedAt      sql.NullTime   `json:"created_at"`
	Position       sql.NullInt64  `json:"position"`
	Active         sql.NullInt64  `json:"active"`
	PageToken      sql.NullString `json:"page_token"`
	HideShorts     sql.NullInt64  `json:"hide_shorts"`
	UnwatchedCount int64          `json:"unwatched_count"`
}

func (q *Queries) ListActiveSubscriptions(ctx context.Context) ([]ListActiveSubscriptionsRow, error) {
	rows, err := q.db.QueryContext(ctx, listActiveSubscriptions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListActiveSubscriptionsRow{}
	for rows.Next() {
		var i ListActiveSubscriptionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.YoutubeID,
			&i.Type,
			&i.ThumbnailUrl,
			&i.LastChecked,
			&i.CreatedAt,
			&i.Position,
			&i.Active,
			&i.PageToken,
			&i.HideShorts,
			&i.UnwatchedCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllSubscriptionsOrdered = `-- name: ListAllSubscriptionsOrdered :many
SELECT s.id, s.name, s.youtube_id, s.type, s.thumbnail_url, s.last_checked, s.created_at, s.position, s.active, s.page_token, s.hide_shorts, COUNT(CASE WHEN v.watched = 0 THEN 1 END) as unwatched_count
FROM subscriptions s
LEFT JOIN videos v ON v.subscription_id = s.id
GROUP BY s.id
ORDER BY s.position, s.name
`

type ListAllSubscriptionsOrderedRow struct {
	ID             int64          `json:"id"`
	Name           string         `json:"name"`
	YoutubeID      string         `json:"youtube_id"`
	Type           string         `json:"type"`
	ThumbnailUrl   sql.NullString `json:"thumbnail_url"`
	LastChecked    sql.NullTime   `json:"last_checked"`
	CreatedAt      sql.NullTime   `json:"created_at"`
	Position       sql.NullInt64  `json:"position"`
	Active         sql.NullInt64  `json:"active"`
	PageToken      sql.NullString `json:"page_token"`
	HideShorts     sql.NullInt64  `json:"hide_shorts"`
	UnwatchedCount int64          `json:"unwatched_count"`
}

func (q *Queries) ListAllSubscriptionsOrdered(ctx context.Context) ([]ListAllSubscriptionsOrderedRow, error) {
	rows, err := q.db.QueryContext(ctx, listAllSubscriptionsOrdered)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAllSubscriptionsOrderedRow{}
	for rows.Next() {
		var i ListAllSubscriptionsOrderedRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.YoutubeID,
			&i.Type,
			&i.ThumbnailUrl,
			&i.LastChecked,
			&i.CreatedAt,
			&i.Position,
			&i.Active,
			&i.PageToken,
			&i.HideShorts,
			&i.UnwatchedCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscriptions = `-- name: ListSubscriptions :many
SELECT id, name, youtube_id, type, thumbnail_url, last_checked, created_at, position, active, page_token, hide_shorts FROM subscriptions ORDER BY name
`

func (q *Queries) ListSubscriptions(ctx context.Context) ([]Subscription, error) {
	rows, err := q.db.QueryContext(ctx, listSubscriptions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.YoutubeID,
			&i.Type,
			&i.ThumbnailUrl,
			&i.LastChecked,
			&i.CreatedAt,
			&i.Position,
			&i.Active,
			&i.PageToken,
			&i.HideShorts,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscriptionsPaginated = `-- name: ListSubscriptionsPaginated :many
SELECT s.id, s.name, s.youtube_id, s.type, s.thumbnail_url, s.last_checked, s.created_at, s.position, s.active, s.page_token, s.hide_shorts, COUNT(CASE WHEN v.watched = 0 THEN 1 END) as unwatched_count
FROM subscriptions s
LEFT JOIN videos v ON v.subscription_id = s.id
GROUP BY s.id
ORDER BY s.position, s.name
LIMIT ? OFFSET ?
`

type ListSubscriptionsPaginatedParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

type ListSubscriptionsPaginatedRow struct {
	ID             int64          `json:"id"`
	Name           string         `json:"name"`
	YoutubeID      string         `json:"youtube_id"`
	Type           string         `json:"type"`
	ThumbnailUrl   sql.NullString `json:"thumbnail_url"`
	LastChecked    sql.NullTime   `json:"last_checked"`
	CreatedAt      sql.NullTime   `json:"created_at"`
	Position       sql.NullInt64  `json:"position"`
	Active         sql.NullInt64  `json:"active"`
	PageToken      sql.NullString `json:"page_token"`
	HideShorts     sql.NullInt64  `json:"hide_shorts"`
	UnwatchedCount int64          `json:"unwatched_count"`
}

func (q *Queries) ListSubscriptionsPaginated(ctx context.Context, arg ListSubscriptionsPaginatedParams) ([]ListSubscriptionsPaginatedRow, error) {
	rows, err := q.db.QueryContext(ctx, listSubscriptionsPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSubscriptionsPaginatedRow{}
	for rows.Next() {
		var i ListSubscriptionsPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.YoutubeID,
			&i.Type,
			&i.ThumbnailUrl,
			&i.LastChecked,
			&i.CreatedAt,
			&i.Position,
			&i.Active,
			&i.PageToken,
			&i.HideShorts,
			&i.UnwatchedCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscriptionsWithUnwatchedCount = `-- name: ListSubscriptionsWithUnwatchedCount :many
SELECT s.id, s.name, s.youtube_id, s.type, s.thumbnail_url, s.last_checked, s.created_at, s.position, s.active, s.page_token, s.hide_shorts, COUNT(CASE WHEN v.watched = 0 THEN 1 END) as unwatched_count
FROM subscriptions s
LEFT JOIN videos v ON v.subscription_id = s.id
GROUP BY s.id
ORDER BY s.name
`

type ListSubscriptionsWithUnwatchedCountRow struct {
	ID             int64          `json:"id"`
	Name           string         `json:"name"`
	YoutubeID      string         `json:"youtube_id"`
	Type           string         `json:"type"`
	ThumbnailUrl   sql.NullString `json:"thumbnail_url"`
	LastChecked    sql.NullTime   `json:"last_checked"`
	CreatedAt      sql.NullTime   `json:"created_at"`
	Position       sql.NullInt64  `json:"position"`
	Active         sql.NullInt64  `json:"active"`
	PageToken      sql.NullString `json:"page_token"`
	HideShorts     sql.NullInt64  `json:"hide_shorts"`
	UnwatchedCount int64          `json:"unwatched_count"`
}

func (q *Queries) ListSubscriptionsWithUnwatchedCount(ctx context.Context) ([]ListSubscriptionsWithUnwatchedCountRow, error) {
	rows, err := q.db.QueryContext(ctx, listSubscriptionsWithUnwatchedCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSubscriptionsWithUnwatchedCountRow{}
	for rows.Next() {
		var i ListSubscriptionsWithUnwatchedCountRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.YoutubeID,
			&i.Type,
			&i.ThumbnailUrl,
			&i.LastChecked,
			&i.CreatedAt,
			&i.Position,
			&i.Active,
			&i.PageToken,
			&i.HideShorts,
			&i.UnwatchedCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnwatchedVideos = `-- name: ListUnwatchedVideos :many
SELECT id, subscription_id, youtube_id, title, thumbnail_url, duration, published_at, watched, created_at, is_short FROM videos WHERE subscription_id = ? AND watched = 0 ORDER BY published_at DESC
`

func (q *Queries) ListUnwatchedVideos(ctx context.Context, subscriptionID int64) ([]Video, error) {
	rows, err := q.db.QueryContext(ctx, listUnwatchedVideos, subscriptionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Video{}
	for rows.Next() {
		var i Video
		if err := rows.Scan(
			&i.ID,
			&i.SubscriptionID,
			&i.YoutubeID,
			&i.Title,
			&i.ThumbnailUrl,
			&i.Duration,
			&i.PublishedAt,
			&i.Watched,
			&i.CreatedAt,
			&i.IsShort,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnwatchedVideosPaginated = `-- name: ListUnwatchedVideosPaginated :many
SELECT id, subscription_id, youtube_id, title, thumbnail_url, duration, published_at, watched, created_at, is_short FROM videos
WHERE subscription_id = ? AND watched = 0
ORDER BY published_at DESC
LIMIT ? OFFSET ?
`

type ListUnwatchedVideosPaginatedParams struct {
	SubscriptionID int64 `json:"subscription_id"`
	Limit          int64 `json:"limit"`
	Offset         int64 `json:"offset"`
}

func (q *Queries) ListUnwatchedVideosPaginated(ctx context.Context, arg ListUnwatchedVideosPaginatedParams) ([]Video, error) {
	rows, err := q.db.QueryContext(ctx, listUnwatchedVideosPaginated, arg.SubscriptionID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Video{}
	for rows.Next() {
		var i Video
		if err := rows.Scan(
			&i.ID,
			&i.SubscriptionID,
			&i.YoutubeID,
			&i.Title,
			&i.ThumbnailUrl,
			&i.Duration,
			&i.PublishedAt,
			&i.Watched,
			&i.CreatedAt,
			&i.IsShort,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnwatchedVideosPaginatedFiltered = `-- name: ListUnwatchedVideosPaginatedFiltered :many
SELECT id, subscription_id, youtube_id, title, thumbnail_url, duration, published_at, watched, created_at, is_short FROM videos
WHERE subscription_id = ?
  AND watched = 0
  AND (? = 0 OR is_short = 0)
ORDER BY published_at DESC
LIMIT ? OFFSET ?
`

type ListUnwatchedVideosPaginatedFilteredParams struct {
	SubscriptionID int64       `json:"subscription_id"`
	Column2        interface{} `json:"column_2"`
	Limit          int64       `json:"limit"`
	Offset         int64       `json:"offset"`
}

func (q *Queries) ListUnwatchedVideosPaginatedFiltered(ctx context.Context, arg ListUnwatchedVideosPaginatedFilteredParams) ([]Video, error) {
	rows, err := q.db.QueryContext(ctx, listUnwatchedVideosPaginatedFiltered,
		arg.SubscriptionID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Video{}
	for rows.Next() {
		var i Video
		if err := rows.Scan(
			&i.ID,
			&i.SubscriptionID,
			&i.YoutubeID,
			&i.Title,
			&i.ThumbnailUrl,
			&i.Duration,
			&i.PublishedAt,
			&i.Watched,
			&i.CreatedAt,
			&i.IsShort,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVideos = `-- name: ListVideos :many
SELECT id, subscription_id, youtube_id, title, thumbnail_url, duration, published_at, watched, created_at, is_short FROM videos WHERE subscription_id = ? ORDER BY published_at DESC
`

func (q *Queries) ListVideos(ctx context.Context, subscriptionID int64) ([]Video, error) {
	rows, err := q.db.QueryContext(ctx, listVideos, subscriptionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Video{}
	for rows.Next() {
		var i Video
		if err := rows.Scan(
			&i.ID,
			&i.SubscriptionID,
			&i.YoutubeID,
			&i.Title,
			&i.ThumbnailUrl,
			&i.Duration,
			&i.PublishedAt,
			&i.Watched,
			&i.CreatedAt,
			&i.IsShort,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markUnwatched = `-- name: MarkUnwatched :exec
UPDATE videos SET watched = 0 WHERE id = ?
`

func (q *Queries) MarkUnwatched(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, markUnwatched, id)
	return err
}

const markWatched = `-- name: MarkWatched :exec
UPDATE videos SET watched = 1 WHERE id = ?
`

func (q *Queries) MarkWatched(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, markWatched, id)
	return err
}

const subscriptionsWithUnwatchedCount = `-- name: SubscriptionsWithUnwatchedCount :many
SELECT s.id, s.name, s.youtube_id, s.type, s.thumbnail_url, s.last_checked, s.created_at, s.position, s.active, s.page_token, s.hide_shorts, COUNT(CASE WHEN v.watched = 0 THEN 1 END) as unwatched_count
FROM subscriptions s
LEFT JOIN videos v ON v.subscription_id = s.id
GROUP BY s.id
ORDER BY s.name
`

type SubscriptionsWithUnwatchedCountRow struct {
	ID             int64          `json:"id"`
	Name           string         `json:"name"`
	YoutubeID      string         `json:"youtube_id"`
	Type           string         `json:"type"`
	ThumbnailUrl   sql.NullString `json:"thumbnail_url"`
	LastChecked    sql.NullTime   `json:"last_checked"`
	CreatedAt      sql.NullTime   `json:"created_at"`
	Position       sql.NullInt64  `json:"position"`
	Active         sql.NullInt64  `json:"active"`
	PageToken      sql.NullString `json:"page_token"`
	HideShorts     sql.NullInt64  `json:"hide_shorts"`
	UnwatchedCount int64          `json:"unwatched_count"`
}

func (q *Queries) SubscriptionsWithUnwatchedCount(ctx context.Context) ([]SubscriptionsWithUnwatchedCountRow, error) {
	rows, err := q.db.QueryContext(ctx, subscriptionsWithUnwatchedCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SubscriptionsWithUnwatchedCountRow{}
	for rows.Next() {
		var i SubscriptionsWithUnwatchedCountRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.YoutubeID,
			&i.Type,
			&i.ThumbnailUrl,
			&i.LastChecked,
			&i.CreatedAt,
			&i.Position,
			&i.Active,
			&i.PageToken,
			&i.HideShorts,
			&i.UnwatchedCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const toggleWatched = `-- name: ToggleWatched :one
UPDATE videos SET watched = NOT watched WHERE id = ?
RETURNING id, subscription_id, youtube_id, title, thumbnail_url, duration, published_at, watched, created_at, is_short
`

func (q *Queries) ToggleWatched(ctx context.Context, id int64) (Video, error) {
	row := q.db.QueryRowContext(ctx, toggleWatched, id)
	var i Video
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.YoutubeID,
		&i.Title,
		&i.ThumbnailUrl,
		&i.Duration,
		&i.PublishedAt,
		&i.Watched,
		&i.CreatedAt,
		&i.IsShort,
	)
	return i, err
}

const updateSubscriptionActive = `-- name: UpdateSubscriptionActive :exec
UPDATE subscriptions SET active = ? WHERE id = ?
`

type UpdateSubscriptionActiveParams struct {
	Active sql.NullInt64 `json:"active"`
	ID     int64         `json:"id"`
}

func (q *Queries) UpdateSubscriptionActive(ctx context.Context, arg UpdateSubscriptionActiveParams) error {
	_, err := q.db.ExecContext(ctx, updateSubscriptionActive, arg.Active, arg.ID)
	return err
}

const updateSubscriptionChecked = `-- name: UpdateSubscriptionChecked :exec
UPDATE subscriptions SET last_checked = CURRENT_TIMESTAMP WHERE id = ?
`

func (q *Queries) UpdateSubscriptionChecked(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, updateSubscriptionChecked, id)
	return err
}

const updateSubscriptionHideShorts = `-- name: UpdateSubscriptionHideShorts :exec
UPDATE subscriptions SET hide_shorts = ? WHERE id = ?
`

type UpdateSubscriptionHideShortsParams struct {
	HideShorts sql.NullInt64 `json:"hide_shorts"`
	ID         int64         `json:"id"`
}

func (q *Queries) UpdateSubscriptionHideShorts(ctx context.Context, arg UpdateSubscriptionHideShortsParams) error {
	_, err := q.db.ExecContext(ctx, updateSubscriptionHideShorts, arg.HideShorts, arg.ID)
	return err
}

const updateSubscriptionPageToken = `-- name: UpdateSubscriptionPageToken :exec
UPDATE subscriptions SET page_token = ? WHERE id = ?
`

type UpdateSubscriptionPageTokenParams struct {
	PageToken sql.NullString `json:"page_token"`
	ID        int64          `json:"id"`
}

func (q *Queries) UpdateSubscriptionPageToken(ctx context.Context, arg UpdateSubscriptionPageTokenParams) error {
	_, err := q.db.ExecContext(ctx, updateSubscriptionPageToken, arg.PageToken, arg.ID)
	return err
}

const updateSubscriptionPosition = `-- name: UpdateSubscriptionPosition :exec
UPDATE subscriptions SET position = ? WHERE id = ?
`

type UpdateSubscriptionPositionParams struct {
	Position sql.NullInt64 `json:"position"`
	ID       int64         `json:"id"`
}

func (q *Queries) UpdateSubscriptionPosition(ctx context.Context, arg UpdateSubscriptionPositionParams) error {
	_, err := q.db.ExecContext(ctx, updateSubscriptionPosition, arg.Position, arg.ID)
	return err
}

const updateVideoIsShort = `-- name: UpdateVideoIsShort :exec
UPDATE videos SET is_short = ? WHERE id = ?
`

type UpdateVideoIsShortParams struct {
	IsShort sql.NullInt64 `json:"is_short"`
	ID      int64         `json:"id"`
}

func (q *Queries) UpdateVideoIsShort(ctx context.Context, arg UpdateVideoIsShortParams) error {
	_, err := q.db.ExecContext(ctx, updateVideoIsShort, arg.IsShort, arg.ID)
	return err
}

const videoExistsByYoutubeID = `-- name: VideoExistsByYoutubeID :one
SELECT EXISTS(SELECT 1 FROM videos WHERE youtube_id = ?)
`

func (q *Queries) VideoExistsByYoutubeID(ctx context.Context, youtubeID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, videoExistsByYoutubeID, youtubeID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}
